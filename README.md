Теоретическая часть

1. “Строгий режим” – директива, которая указывается в самом начале кода, делает код «более строгим» и безопасным, например выдает эксепшены там, где их не было бы в обычно режиме (объявление глобальных переменных, изменение значений глобальных переменных, одинаковые названия аргументов функции и т.п.).
2. let и const имеют блочную область видимости, а var – функциональную, из-за этого var может «всплывать», поэтому предпочтительнее всегда использовать let и const.
   const используется для объявления константы, которую в дальнейшем нельзя изменить, let – для объявления изменяемой переменной.
3. Операторы сравнения:
   ‘==’ и ‘===’, ‘!=’ и ‘!==’ отличаются тем, что в обоих случаях в первом варианте происходит нестрогое сравнение, которое не учитывает типы данных, при котором JS будет неявно преобразовывать типы данных к одному.
   ‘01’ == ‘1’: true, так как сравнение нестрогое и происходит преобразование типов (к числу).
   null === undefined: false, так как сравнение учитывает типы, при нестрогой проверки будет – true.
   null > 0; null == 0 – в обоих случаях false, так как null при == null не равен ничему, кроме null и undefined, а при сравнении > < <= >= null приводится к 0, поэтомук null >= 0 - true.
   undefined > 0; undefined < 0; undefined == 0? Во всех случаях false, так как он ничему не равен, кроме случая нестрого сравнения с null.

4. Можно ли сохранить функцию в переменную? Можно, например:
function log(a) {
  console.log(a)
}
const newLog = log
log(1)     //1
newLog(2)  //2

5. Функция коллбэк :
const callbackFn = (question: string, fnAgree: () => void, fnDisagree: () => void) => {
  const answer = Boolean(prompt(question))
  answer ? fnAgree() : fnDisagree()
}

6. this – контекст выполнения функции, является динамическим и определяется в момент выполнения. Стрелочные функции не имеют своего this и берут его из лексического окружения.
Пример потери контекста:
const user = {
  name: "user",
  logName() {
   console.log(this.name)
 },
}
setTimeout(user.logName, 3000)

Пример привязки контекста при помощи bind:
const user = {
  name: "user",
  logName() {
    console.log(this.name)
  },
}
Пример при использовании стрелочной функции:
setTimeout(user.logName.bind(user), 3000)
const user = {
  name: "user",
  logName() {
    console.log(this.name)
  },
  logNameTimeout() {
    setTimeout(() => {
    console.log(this.name)
    }, 1000)
  },
} 

7. setTimeout – вызывает передаваемую функцию через передаваемое значение времени. setInterval – то же самое, но вызывает функцию циклично через передаваемые промежутки времени. Используются в основном для временных сообщений, которые необходимо показать после определенного действия, для асинхронных запросов (например повторить запрос через некоторое время или отменить его), для различных таймеров.
Рекурсивный setTimeout делает задержку вызова функции от окончания предыдущего вызова до начала следующего, то есть ожидается, когда функция будет выполнена. А setInterval не дожидается окончания функции. По факту, в setInterval промежуток между началом выполнения функции и между окончанием предыдущей функции меньше передаваемого значения задержки в setInterval.
Для того, чтобы отменить планировщики функции, необходимо при объявлении их поместить в переменную, а затем вызвать clearInterval или clearTimeout, передав туда название переменной.

8. Typescript - строго типизированный язык программирования, который основан на JS. Создан для уменьшения количества багов при разработке. Отличается от JS тем, что переменные имеют привязку к определенному типу данных, в отличие от JS, где переменные могут изменять тип данных в рантайме.

9. Дженерики используются, когда мы заранее не знаем, какой тип данных будет передан в функцию, например:
function returnFirstElem<T>(array: T[]): T {
	return array[0]
}
returnFirstElem<number>([1, 2, 3])
returnFirstElem<string>([1, 2, 3]) //ошибка

10. interface и type используются для описания типов данных. Интерфейс, как правило, используется для описания свойств объекта. Также при объявлении класса можно указать через ключевое слово implements, что класс будет использовать методы интерфейса.
type, как правило, используется для более простого определения типов, например:
type MyType = string | number
type AnotherMyType = MyType & undefined

11. Сделать часть свойств интерфейса необязательными :
interface Props {
	a?: string
	b?: string
	c: number
}
Сделать все свойства необязательными:
interface NewProps extends Partial<Props> {}

12. Omit нужен для объявления нового типа данных на основе имеющегося, за исключением полей, который мы передаем, например:
interface Props {
	a: string
	b: string
}
type NewProps = Omit<Props, 'a'> - останется только свойство b

13. Перегрузка функций в TS, пример:
function myFn(a: number, b: number): number
function myFn(a: string, b: string): string
function myFn(a: number | string, b: number | string): number | string | undefined {
	if (typeof a === "number" && typeof b === "number") return a + b
	if (typeof a === "string" && typeof b === "string") return a + b
}